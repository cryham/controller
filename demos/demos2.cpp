#include "demos.h"


//  CrystaL KeyboarD  logo lines
//....................................................................................
//  x,y points, 0 break
const static int word1[] = {
/*C*/194,43, 120,133, 8,193, 112,233, 224,299, 0,
	224,299, 141,227, 78,194, 144,139, 194,43, 0,
/*R*/192,110, 260,156, 211,176, 164,201, 220,153, 192,110, 0,
	164,201, 248,222, 314,258, 298,276, 251,237, 164,201, 0,
/*Y*/303,189, 388,224 , 450,190, 398,256 , 331,328, 374,242, 303,189, 0,
/*S*/541,92, 439,152, 533,196, 435,267, 507,226, 574,197, 517,173, 473,147, 541,92, 0,
/*T*/544,62, 628,61, 692,33, 629,75, 592,167, 615,76, 544,62, 0,
/*A*/623,216, 660,154, 673,82, 702,152, 746,206, 679,144, 623,216, 0,
/*L*/766,28, 793,147, 781,233, 738,300, 818,256,
	935,220, 815,229, 800,133, 766,28, 0, -100};
const static int word2[] = {
/*K*/217,345, 152,396, 62,440, 176,468, 288,507, 248,481, 117,438, 173,397, 217,345, 0,
	76,367, 118,471, 130,541, 145,516, 76,367, 0,
/*e*/329,359, 282,404, 207,434, 292,471, 368,517, 306,467, 256,438,
	318,433, 257,429, 297,401, 329,359, 0,
/*y*/357,450, 386,488, 424,507, 387,541, 334,561, 373,568, 427,521,
	468,453, 431,497, 357,450, 0,
/*b*/466,369, 492,399, 523,412, 486,435, 540,457, 505,476, 474,517,
	506,459, 486,435, 494,414, 466,369, 0,
/*o*/533,432, 557,414, 571,382, 587,409, 609,426, 591,452, 576,496, 559,455, 533,432, 0,
	573,409, 595,426, 575,461, 552,433, 573,409, 0,
/*a*/583,535, 608,493, 628,444, 649,477, 675,506, 630,481, 583,535, 0,
/*r*/660,385, 694,407, 651,427, 727,471, 706,479, 682,450,
	651,427, 670,407, 660,385, 0,
/*D*/717,363, 796,400, 861,432, 805,479, 761,504, 726,543,
	749,501, 795,445, 776,411, 717,363, 0, -100};

const static int
	cxw[2] = {496,402}, cyw[2] = {130,160},  // centers
	axw[2] = {222,262}, ayw[2] = {362,282};  // amplitudes
	
void Demos::CK_logo(Adafruit_SSD1306& d)
{
	#define K 1024  // wave																		// scale ofs
	#define CX(x) {  x = w-cx;  x = ( (x*(K +ax*Cos(8*w      +tt[0])/SY*Sin(7*w      +tt[1])/SY) /K) +cx)/8 +6;  }
	#define CY(y) {  y = w-cy;  y = ( (y*(K +ay*Cos(9*w+ x*73+tt[2])/SY*Sin(6*w+ x*52+tt[3])/SY) /K) +cy)/9 -1;  }

	const uint tt[4] = {t*7,t*5,t*8,t*5};
	for (int w2=0; w2<2; ++w2)
	{
		const int cx = cxw[w2], cy = cyw[w2];
		const int ax = axw[w2], ay = ayw[w2];
		int a=0,w, i=0,rst=1,
			x1=0,y1=0,x=0,y=0;
		do
		{	w = w2 ? word2[a++] : word1[a++];
			if (w<=0) {  rst=1;  i=0;  }
			else
			if (rst)  switch(i)
			{	case 0:  CX(x)  ++i;  break;
				case 1:  CY(y)  rst=0; i=0;  break;  }
			else  switch(i)
			{	case 0:  x1=x;  CX(x)  ++i;  break;
				case 1:  y1=y;  CY(y)  i=2;  break;  }

			if (i==2)
			{	i=0;  d.drawLine(x1,y1, x,y, WHITE);  }
		}
		while (w >= 0);
	}
	++t;
}


//  Cube 3D
//....................................................................................
#define NP  8
const static int8_t pp[NP][3] = {   // points
	{-1,-1,-1},{ 1,-1,-1}, {-1, 1,-1},{ 1, 1,-1},
	{-1,-1, 1},{ 1,-1, 1}, {-1, 1, 1},{ 1, 1, 1} };
#define NE  12
const uint8_t ee[NE][2] = {   // edges
	{0,1},{0,2},{0,4}, {3,1},{3,2},{3,7},
	{5,1},{5,4},{5,7}, {6,2},{6,4},{6,7}};

void Demos::Cube(Adafruit_SSD1306& d)
{
	#define s 426
	#define zz 256*4
	++t;
	float rx = t*0.010, cx = cos(rx), sx = sin(rx);
	float ry = t*0.013, cy = cos(ry), sy = sin(ry);
	float rz = t*0.016, cz = cos(rz), sz = sin(rz);
	float mx[3][3] = {{1,0,0},{0,cx,-sx},{0,sx,cx}};
	float my[3][3] = {{cy,0,sy},{0,1,0},{-sy,0,cy}};
	float mz[3][3] = {{cz,-sz,0},{sz,cz,0},{0,0,1}};

	int p[NP][2];
	int i;
	for (i=0; i < NP; ++i)
	{
		float x = pp[i][0], y = pp[i][1], z = pp[i][2];
		float v[3];  // rotate
		v[0] = mx[0][0]*x +mx[0][1]*y +mx[0][2]*z;
		v[1] = mx[1][0]*x +mx[1][1]*y +mx[1][2]*z;
		v[2] = mx[2][0]*x +mx[2][1]*y +mx[2][2]*z;
		x = v[0];  y = v[1];  z = v[2];
		v[0] = my[0][0]*x +my[0][1]*y +my[0][2]*z;
		v[1] = my[1][0]*x +my[1][1]*y +my[1][2]*z;
		v[2] = my[2][0]*x +my[2][1]*y +my[2][2]*z;
		x = v[0];  y = v[1];  z = v[2];
		v[0] = mz[0][0]*x +mz[0][1]*y +mz[0][2]*z;
		v[1] = mz[1][0]*x +mz[1][1]*y +mz[1][2]*z;
		v[2] = mz[2][0]*x +mz[2][1]*y +mz[2][2]*z;
		x = v[0] * s;  y = v[1] * s;  z = v[2] * s + zz;

		p[i][0] = H/2 * x / z +W/2;  // pos 3d to 2d
		p[i][1] = H/2 * y / z +H/2;
	}
	for (i=0; i < NE; ++i)
	{
		int e0 = ee[i][0], e1 = ee[i][1];
		d.drawLine(
			p[e0][0],p[e0][1],
			p[e1][0],p[e1][1], WHITE);
	}
	delay(8);
}
